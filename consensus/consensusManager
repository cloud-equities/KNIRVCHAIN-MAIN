package consensus

import (
	"blockchain/block"
	"blockchain/constants"
	"blockchain/peerManager"
	"log"
	"time"
)

func (bcs *BlockchainServer) RunConsensus() {

	for {
		log.Println("Starting the consensus algorithm...")
		bc := peerManager.GetPeerManager(nil, nil)
		longestChain := bcs.BlockchainPtr.Blocks
		lengthOfTheLongestChain := bcs.BlockchainPtr.Blocks[len(bcs.BlockchainPtr.Blocks)-1].BlockNumber + 1
		longestChainIsOur := true
		Peers := bcs.BlockchainPtr.Peers
		for peer, status := range Peers {
			if peer != bcs.BlockchainPtr.Address && status {
				bc1, err := peerManager.FetchLastNBlocks(peer)
				if err != nil {
					log.Println("Error while  fetching last n blocks from peer:", peer, "Error:", err.Error())
					continue
				}

				lengthOfTheFetchedChain := bc1.Blocks[len(bc1.Blocks)-1].BlockNumber + 1
				if lengthOfTheFetchedChain > lengthOfTheLongestChain {
					longestChain = bc.BlockchainPtr.Blocks
					lengthOfTheLongestChain = lengthOfTheFetchedChain
					longestChainIsOur = false
				}
			}
		}

		if longestChainIsOur {
			log.Println("My chain is longest, thus I am not updating my blockchain")
			time.Sleep(constants.CONSENSUS_PAUSE_TIME * time.Second)
			continue
		}

		remoteBlocks := make([]*block.Block, len(longestChain))
		for i, block := range longestChain {
			remoteBlocks[i] = &block.Block{
				BlockNumber:  block.BlockNumber,
				PrevHash:     block.PrevHash,
				Timestamp:    block.Timestamp,
				Nonce:        block.Nonce,
				Transactions: block.Transactions,
			}
		}
		if peerManager.GetPeerManager(nil, nil).VerifyLastNBlocks(remoteBlocks) {
			// stop the Mining until updation
			bcs.MiningLocked = true
			remoteBlocks := make([]*block.Block, len(longestChain))
			for i, block := range longestChain {
				remoteBlocks[i] = &block.Block{
					BlockNumber:  block.BlockNumber,
					PrevHash:     block.PrevHash,
					Timestamp:    block.Timestamp,
					Nonce:        block.Nonce,
					Transactions: block.Transactions,
				}
			}
			remotePeerBlocks := make([]*peerManager.RemoteBlock, len(remoteBlocks))
			for i, block := range remoteBlocks {
				remotePeerBlocks[i] = &peerManager.RemoteBlock{
					BlockNumber:  block.BlockNumber,
					PrevHash:     block.PrevHash,
					Timestamp:    block.Timestamp,
					Nonce:        block.Nonce,
					Transactions: block.Transactions,
				}
			}
			peerManager.GetPeerManager(nil, nil).UpdateBlockchain(remotePeerBlocks)
			// restart the Mining as updation is complete
			bcs.MiningLocked = false
			log.Println("Updation of Blockchain complete !!!")
		} else {
			log.Println("Chain Verification Failed, Hence not updating my blockchain")
		}

		time.Sleep(constants.CONSENSUS_PAUSE_TIME * time.Second)
	}

}
